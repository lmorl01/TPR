# David Morley, MSc Bioinformatics 2015-2017
# MSc Project: Origin & Evolution of TPR Domains
# Version: 002, 13/03/2017
#
# Purpose: Write a script to populate the the following table:
#
# +-------------------+-------------+------+-----+---------+----------------+
# | Field             | Type        | Null | Key | Default | Extra          |
# +-------------------+-------------+------+-----+---------+----------------+
# | resultId          | int(11)     | NO   | PRI | NULL    | auto_increment |
# | experimentId      | int(11)     | YES  | MUL | NULL    |                |
# | resultPdb         | char(4)     | YES  | MUL | NULL    |                |
# | resultPdbText     | varchar(50) | YES  |     | NULL    |                |
# | score             | float       | YES  |     | NULL    |                |
# | probability       | float       | YES  |     | NULL    |                |
# | rmsd              | float       | YES  |     | NULL    |                |
# | len1              | int(11)     | YES  |     | NULL    |                |
# | len2              | int(11)     | YES  |     | NULL    |                |
# | cov1              | int(11)     | YES  |     | NULL    |                |
# | cov2              | int(11)     | YES  |     | NULL    |                |
# | percentId         | float       | YES  |     | NULL    |                |
# | alignedResidues   | int(11)     | YES  |     | NULL    |                |
# | targetDescription | text        | YES  |     | NULL    |                |
# +-------------------+-------------+------+-----+---------+----------------+
#
# Program writes lines of the form:
# INSERT IGNORE INTO PDBEntry (pdbCode) VALUES (CHAR(4));
# INSERT INTO Results (experimentId, resultPdb, resultPdbText, score, probability, rmsd, len1, len2, cov1, cov2, percentId, alignedResidues, 
# targetDescription) VALUES (INT, CHAR(4), VARCHAR, FLOAT, FLOAT, FLOAT, INT, INT, INT, INT, FLOAT, INT, TEXT)
#
# Usage: perl writePopulateResults.pl experimentId results_CUSTOM.out populateResults.sql
# where...
# experimentId is a foreign key to an entry in the table Experiment 
# results_CUSTOM.out is an output file in the standard format produced by the FATCAT program
# populateResults.sql is the output file
#

use strict;
use warnings;

sub determineTargetPdb($);
sub writePdbEntry($$);
sub writeResults($$$$$$$$$$$$$);

if (!(scalar @ARGV == 3 && $ARGV[0] =~ /^\d+$/)){
	print "Usage: perl writePopulateResults.pl experimentId results_CUSTOM.out populateResults.sql\n";
	exit;
}

 my $experimentId = $ARGV[0];
 my $in = $ARGV[1];
 my $out = $ARGV[2];
 open(OUTFILE, ">$out")
	 or die "Can't create output file $out\n";
open(INFILE, $in)
      or die "Can't open file $in\n";  

my $header = <INFILE>; 	#Discard the first line of the file 
$header = <INFILE>; 	#Discard the second line of the file
$header = <INFILE>;		#Read the input file so that the query PDB can be extracted

if ($header =~ m/([a-z0-9]{4})(_[0-9])?_TPR/){
	my $queryPdb = $1;
	print "Query PDB: ", $queryPdb, "\n";
}
else {
	die "Unable to extract Query PDB Code from $in\n"; 
}


# my $testLine = <INFILE>;
# my @values = split /\t/, $testLine;
# print scalar(@values);
 # for (my $i=0; $i < scalar(@values); $i++){
	 # print $i, ": ", $values[$i], "\n";
 # }
#print "Probability: ", $values[3]*2, "\n";
#print "Probability: ", sprintf("%.10g", $values[3]), "\n";

while (my $line = <INFILE>) {
	my @results = split /\t/, $line;	
	my $targetPdb = determineTargetPdb($results[1]);
	my $alignedResidues = int (($results[5]/100)*$results[7]);
	writePdbEntry($targetPdb, $results[10]);
	writeResults($experimentId, $targetPdb, $results[1], $results[2], $results[3], $results[4], $results[5], $results[6], $results[7], $results[8], $results[9], $alignedResidues, $results[10]);
 }  
 close(INFILE) or die "Unable to close input file";

 close(OUTFILE) or die "Unable to close output file";

 
 
 #########################################################################
# Purpose: 	To extract the target PDB code from a line of output generated by FATCAT
# Arguments: 
# 	string 		$_[0]: the line of output that the PDB code needs to be extracted from
# Return: 
#	a string representing the four-character PDB code in lowercase
# Assumptions:
#	The PDB codes will come in one of three formats as per the examples below:
#	CUSTOM	d1914a1		# The PDB code comes after the 'd'
#	CUSTOM	1APY.A		# The PDB code comes immediately after the white space and is 
#						followed by a '.' and an upper or lower case letter or number
#	CUSTOM	PDP:2WPXAc	# The PDB code comes after 'PDP:'
# Error Behaviour: 
#	If there's no match to any of the formats above, an error message is printed
#	to STDERR reporting the message "Couldn't process: " + the line that could
#	not be processed.
#########################################################################
 sub determineTargetPdb($){ 

 if ($_[0] =~ m/^d([A-Za-z0-9:.]+_?)$/){
	return lc substr($1,0,4);
 } elsif ($_[0] =~ m/^PDP:([A-Za-z0-9:.]+_?)$/){
	return lc substr($1,0,4);
 } elsif ($_[0] =~ m/^([A-Z0-9]{4}).[A-Za-z0-9]{1}$/){
	return lc $1;
 } else {
	print STDERR "Couldn't process ", $_[0], "\n";
 }
 
}

 sub writePdbEntry($$){
	# my ($regionId, $startResidue, $endResidue, $tprOrdinal) = split /,/, $line, 4;
	print OUTFILE "INSERT IGNORE INTO PDBEntry (pdbCode) VALUES (\"$_[0]\");\n";
 }
 
 sub writeResults($$$$$$$$$$$$$){
	print OUTFILE "INSERT INTO Results (experimentId, resultPdb, resultPdbText, score, probability, rmsd, len1, len2, cov1, cov2, percentId, alignedResidues, targetDescription) VALUES ($_[0], \"$_[1]\", \"$_[2]\", $_[3], $_[4], $_[5], $_[6], $_[7], $_[8], $_[9], $_[10], $_[11], \"$_[12]\");\n";
 }




